"use client";

import { useState, useMemo, useCallback, useEffect } from "react";
import { useWallets } from "@privy-io/react-auth";
import { toViemAccount } from "@privy-io/react-auth";
import Section from "../reusables/section";
import { showSuccessToast, showErrorToast } from "@/components/ui/custom-toast";
import { createKernelAccount, addressToEmptyAccount } from "@zerodev/sdk";
import { signerToEcdsaValidator } from "@zerodev/ecdsa-validator";
import { http, Hex, createPublicClient, Address } from "viem";
import { generatePrivateKey, privateKeyToAccount } from "viem/accounts";
import { baseSepolia } from "viem/chains";
import { toECDSASigner } from "@zerodev/permissions/signers";
import { toSudoPolicy } from "@zerodev/permissions/policies";
import {
  serializePermissionAccount,
  toPermissionValidator,
} from "@zerodev/permissions";
import { getEntryPoint, KERNEL_V3_1 } from "@zerodev/sdk/constants";

type WalletInfo = {
  address: string;
  type: "ethereum";
  name: string;
};

type SessionKeyInfo = {
  privateKey: Hex;
  address: Address;
  approval?: string;
  smartAccountAddress?: Address;
};

const ZeroDevSessionKeys = () => {
  const { wallets } = useWallets();
  const [selectedWallet, setSelectedWallet] = useState<WalletInfo | null>(null);
  const [sessionKey, setSessionKey] = useState<SessionKeyInfo | null>(null);
  const [smartAccount, setSmartAccount] = useState<Address | null>(null);
  const [isLoading, setIsLoading] = useState(false);
  const [transactionStatus, setTransactionStatus] = useState<string>("");

  const allWallets = useMemo((): WalletInfo[] => {
    return wallets.map((wallet) => ({
      address: wallet.address,
      type: "ethereum" as const,
      name: `${wallet.address.slice(0, 6)}...${wallet.address.slice(-4)}`,
    }));
  }, [wallets]);

  useEffect(() => {
    if (allWallets.length > 0 && !selectedWallet) {
      setSelectedWallet(allWallets[0]);
    }
  }, [allWallets, selectedWallet]);

  // Initialize ZeroDev clients
  const { publicClient, entryPoint } = useMemo(() => {
    if (!process.env.NEXT_PUBLIC_ZERODEV_RPC) {
      return { publicClient: null, entryPoint: null };
    }

    const client = createPublicClient({
      transport: http(process.env.NEXT_PUBLIC_ZERODEV_RPC),
      chain: baseSepolia,
    });

    const ep = getEntryPoint("0.7");

    return { publicClient: client, entryPoint: ep };
  }, []);

  // Step 1: Create ZeroDev Smart Account using Privy wallet as owner
  const createSmartAccount = useCallback(async () => {
    if (!selectedWallet || !publicClient || !entryPoint) {
      showErrorToast("Please select a wallet and ensure ZeroDev is configured");
      return;
    }

    setIsLoading(true);
    try {
      // Find the selected Privy wallet
      const privyWallet = wallets.find(
        (w) => w.address === selectedWallet.address
      );
      if (!privyWallet) {
        throw new Error("Selected wallet not found");
      }

      // Convert Privy wallet to viem account
      const privyWalletSigner = await toViemAccount({
        wallet: privyWallet,
      });

      // Create ECDSA validator for the Privy wallet
      const ecdsaValidator = await signerToEcdsaValidator(publicClient, {
        entryPoint,
        signer: privyWalletSigner,
        kernelVersion: KERNEL_V3_1,
      });

      // Create the smart account with Privy wallet as owner
      const smartAccount = await createKernelAccount(publicClient, {
        entryPoint,
        plugins: {
          sudo: ecdsaValidator,
        },
        kernelVersion: KERNEL_V3_1,
      });

      setSmartAccount(smartAccount.address);
      showSuccessToast(
        `Smart Account created: ${smartAccount.address.slice(
          0,
          6
        )}...${smartAccount.address.slice(-4)}`
      );
    } catch (error) {
      console.error("Error creating smart account:", error);
      showErrorToast(
        `Failed to create smart account: ${
          error instanceof Error ? error.message : "Unknown error"
        }`
      );
    } finally {
      setIsLoading(false);
    }
  }, [selectedWallet, publicClient, entryPoint, wallets]);

  // Step 2: Generate session key (server-side key)
  const generateServerSessionKey = useCallback(async () => {
    if (!smartAccount) {
      showErrorToast("Please create smart account first");
      return;
    }

    setIsLoading(true);
    try {
      // This represents a key generated by your server
      const sessionPrivateKey = generatePrivateKey();
      const sessionKeyAccount = privateKeyToAccount(sessionPrivateKey);

      const newSessionKey: SessionKeyInfo = {
        privateKey: sessionPrivateKey,
        address: sessionKeyAccount.address,
        smartAccountAddress: smartAccount,
      };

      setSessionKey(newSessionKey);
      showSuccessToast(
        `Server session key generated: ${sessionKeyAccount.address.slice(
          0,
          6
        )}...${sessionKeyAccount.address.slice(-4)}`
      );
    } catch (error) {
      console.error("Error generating session key:", error);
      showErrorToast("Failed to generate session key");
    } finally {
      setIsLoading(false);
    }
  }, [smartAccount]);

  // Step 3: Privy wallet approves the server's session key
  const approveSessionKey = useCallback(async () => {
    if (
      !selectedWallet ||
      !sessionKey ||
      !smartAccount ||
      !publicClient ||
      !entryPoint
    ) {
      showErrorToast("Missing required data for approval");
      return;
    }

    setIsLoading(true);
    try {
      // Find the selected Privy wallet
      const privyWallet = wallets.find(
        (w) => w.address === selectedWallet.address
      );
      if (!privyWallet) {
        throw new Error("Selected wallet not found");
      }

      // Convert Privy wallet to viem account for signing the approval
      const privyWalletSigner = await toViemAccount({
        wallet: privyWallet,
      });

      // Create ECDSA validator for the Privy wallet (sudo permissions)
      const ecdsaValidator = await signerToEcdsaValidator(publicClient, {
        entryPoint,
        signer: privyWalletSigner,
        kernelVersion: KERNEL_V3_1,
      });

      // Create an "empty account" for the server's session key
      const emptySessionAccount = addressToEmptyAccount(sessionKey.address);
      const emptySessionKeySigner = await toECDSASigner({
        signer: emptySessionAccount,
      });

      const permissionPlugin = await toPermissionValidator(publicClient, {
        entryPoint,
        signer: emptySessionKeySigner,
        policies: [
          // In production, use restrictive policies instead of sudo
          toSudoPolicy({}),
        ],
        kernelVersion: KERNEL_V3_1,
      });

      // Create the smart account with session key permissions
      const sessionKeyAccount = await createKernelAccount(publicClient, {
        entryPoint,
        plugins: {
          sudo: ecdsaValidator, // Privy wallet as sudo
          regular: permissionPlugin, // Session key permissions
        },
        kernelVersion: KERNEL_V3_1,
      });

      // Serialize the permission (this would be sent to your server)
      const approval = await serializePermissionAccount(sessionKeyAccount);

      setSessionKey((prev) => (prev ? { ...prev, approval } : null));
      showSuccessToast("Privy wallet approved server session key!");
    } catch (error) {
      console.error("Error getting approval:", error);
      showErrorToast(
        `Failed to get approval: ${
          error instanceof Error ? error.message : "Unknown error"
        }`
      );
    } finally {
      setIsLoading(false);
    }
  }, [
    selectedWallet,
    sessionKey,
    smartAccount,
    publicClient,
    entryPoint,
    wallets,
  ]);

  // Step 4: Server executes transaction using session key (via API)
  const executeServerTransaction = useCallback(async () => {
    if (!sessionKey?.approval) {
      showErrorToast("Session key not approved yet");
      return;
    }

    setIsLoading(true);
    setTransactionStatus("Sending session key to server...");

    try {
      // Call our server API endpoint
      const response = await fetch("/api/execute-session-transaction", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          sessionKeyPrivateKey: sessionKey.privateKey,
          approval: sessionKey.approval,
        }),
      });

      const data = await response.json();

      if (!response.ok) {
        throw new Error(data.details || data.error || "Server request failed");
      }

      setTransactionStatus("Server executed transaction successfully!");
      showSuccessToast(
        `Server executed transaction: ${data.userOpHash.slice(0, 10)}...`
      );

      setTransactionStatus(
        `Server transaction completed! TX: ${data.transactionHash.slice(
          1,
          10
        )}...`
      );
      showSuccessToast(
        `Transaction successful: ${data.transactionHash.slice(0, 10)}...`
      );
    } catch (error) {
      console.error("Error calling server API:", error);
      const errorMessage =
        error instanceof Error ? error.message : "Unknown error";
      setTransactionStatus(`Server API error: ${errorMessage}`);
      showErrorToast(`Server transaction failed: ${errorMessage}`);
    } finally {
      setIsLoading(false);
    }
  }, [sessionKey]);

  const resetDemo = useCallback(() => {
    setSessionKey(null);
    setSmartAccount(null);
    setTransactionStatus("");
    showSuccessToast("Demo reset");
  }, []);

  const availableActions = [
    {
      name: "1. Create Smart Account",
      function: createSmartAccount,
      disabled: isLoading || !!smartAccount,
    },
    {
      name: "2. Generate Server Session Key",
      function: generateServerSessionKey,
      disabled: isLoading || !smartAccount || !!sessionKey,
    },
    {
      name: "3. Approve Session Key (Privy Wallet)",
      function: approveSessionKey,
      disabled: isLoading || !sessionKey || !!sessionKey?.approval,
    },
    {
      name: "4. Server Execute Transaction",
      function: executeServerTransaction,
      disabled: isLoading || !sessionKey?.approval,
    },
    {
      name: "Reset Demo",
      function: resetDemo,
      disabled: isLoading,
    },
  ];

  return (
    <Section
      name="Session Keys (AA)"
      description="This section shows how a Privy embedded wallet can be used to create a ZeroDev smart account, delegate session keys to a server, and allow the server to execute transactions autonomously."
      filepath="src/components/sections/zerodev-session-keys"
      actions={availableActions}
    >
      <div className="space-y-4">
        <div>
          <label
            htmlFor="zerodev-wallet-select"
            className="block text-sm font-medium mb-2"
          >
            Privy Wallet (Smart Account Owner):
          </label>
          <select
            id="zerodev-wallet-select"
            value={selectedWallet?.address || ""}
            onChange={(e) => {
              const wallet = allWallets.find(
                (w) => w.address === e.target.value
              );
              setSelectedWallet(wallet || null);
            }}
            className="w-full pl-3 pr-8 py-2 border border-[#E2E3F0] rounded-md bg-white text-black focus:outline-none focus:ring-1 focus:ring-black"
            disabled={isLoading}
          >
            {allWallets.length === 0 ? (
              <option value="">
                No Privy wallets available - create one first
              </option>
            ) : (
              <>
                <option value="">Select a Privy wallet</option>
                {allWallets.map((wallet) => (
                  <option key={wallet.address} value={wallet.address}>
                    {wallet.name} ({wallet.address})
                  </option>
                ))}
              </>
            )}
          </select>
        </div>

        {smartAccount && (
          <div className="bg-green-50 border border-green-200 rounded-md p-4">
            <h4 className="font-medium text-green-800 mb-2">
              ✅ ZeroDev Smart Account Created
            </h4>
            <div className="text-sm text-green-700">
              <div>
                <span className="font-medium">Smart Account:</span>{" "}
                <code>{smartAccount}</code>
              </div>
              <div>
                <span className="font-medium">Owner:</span> Privy Wallet (
                {selectedWallet?.address})
              </div>
            </div>
          </div>
        )}

        {sessionKey && (
          <div className="bg-blue-50 border border-blue-200 rounded-md p-4">
            <h4 className="font-medium text-blue-800 mb-2">
              🔑 Server Session Key
            </h4>
            <div className="space-y-2 text-sm">
              <div>
                <span className="font-medium">Server Key Address:</span>{" "}
                <code className="text-blue-700">{sessionKey.address}</code>
              </div>
              <div>
                <span className="font-medium">Status:</span>{" "}
                <span
                  className={
                    sessionKey.approval ? "text-green-600" : "text-orange-600"
                  }
                >
                  {sessionKey.approval
                    ? "✅ Approved by Privy Wallet"
                    : "⏳ Awaiting Approval"}
                </span>
              </div>
            </div>
          </div>
        )}

        {transactionStatus && (
          <div className="bg-gray-50 border border-gray-200 rounded-md p-4">
            <h4 className="font-medium text-gray-800 mb-2">Server Activity</h4>
            <p className="text-sm text-gray-700">{transactionStatus}</p>
          </div>
        )}

        {isLoading && (
          <div className="flex items-center justify-center py-4">
            <div className="animate-spin rounded-full h-6 w-6 border-b-2 border-blue-600"></div>
            <span className="ml-2 text-sm text-gray-600">Processing...</span>
          </div>
        )}
      </div>
    </Section>
  );
};

export default ZeroDevSessionKeys;
